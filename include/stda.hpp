#ifndef STDA_HPP
#define STDA_HPP
#include <future>
#include <chrono>
#include <cassert>
#include <cstring>
#include <unordered_map>
#include <deque>
#include <string>
#include <mutex>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <atomic>
#include <thread>
#include <tuple>
#include <cstddef>
#include <functional>
#include <utility>
#include <exception>
#include <condition_variable>
#include <iostream>
namespace stda {class rejected_execution_error : public std::runtime_error{public:explicit rejected_execution_error(const std::string& what_arg): std::runtime_error(what_arg){}explicit rejected_execution_error(const char* what_arg): std::runtime_error(what_arg){}};class thread_pool{public:using size_type = size_t;template <class T>
using Callable = std::function<T()>;using Runnable = Callable<void>;private:struct shared_state{std::mutex d_mutex;std::unordered_map<std::thread::id, std::thread> d_handles;std::deque<Runnable> d_tasks;std::condition_variable d_signalTaskAdded;std::condition_variable d_signalThreadDespawn;size_type d_minThreads;size_type d_maxThreads;std::chrono::nanoseconds d_maxIdleTime;size_type d_activeThreads;bool d_isShutdown;shared_state(size_type min_threads,size_type max_threads,const std::chrono::nanoseconds& max_idle_time): d_minThreads(min_threads),d_maxThreads(max_threads),d_maxIdleTime(max_idle_time),d_activeThreads(0),d_isShutdown(false){}};std::shared_ptr<shared_state> d_state;std::atomic<bool> d_acceptingTasks;public:template <class Rep, class Period>
thread_pool(size_type min_threads,size_type max_threads,std::chrono::duration<Rep, Period> max_idle_time): d_state(std::make_shared<shared_state>(min_threads, max_threads,std::chrono::duration_cast<std::chrono::nanoseconds>(max_idle_time))),d_acceptingTasks(true){for (size_t i = 0; i < min_threads; i++){add_thread();}}~thread_pool(){shutdown_now();}thread_pool(const thread_pool& pool) = delete;thread_pool(thread_pool&& pool) = delete;thread_pool& operator=(const thread_pool& pool) = delete;size_t get_core_pool_size() const{std::lock_guard<std::mutex> lck(d_state->d_mutex);return d_state->d_minThreads;}size_t get_maximum_pool_size() const{std::lock_guard<std::mutex> lck(d_state->d_mutex);return d_state->d_maxThreads;}size_t get_pool_size() const{std::lock_guard<std::mutex> lck(d_state->d_mutex);return d_state->d_handles.size();}size_t get_active_count() const{std::lock_guard<std::mutex> lck(d_state->d_mutex);return d_state->d_activeThreads;}bool is_shutdown() const{std::lock_guard<std::mutex> lck(d_state->d_mutex);return d_state->d_isShutdown;}bool is_terminated() const{std::lock_guard<std::mutex> lck(d_state->d_mutex);return d_state->d_isShutdown && d_state->d_tasks.empty();}void shutdown(){d_acceptingTasks = false;{std::lock_guard<std::mutex> lck(d_state->d_mutex);d_state->d_isShutdown = true;}d_state->d_signalTaskAdded.notify_all();}std::deque<Runnable> shutdown_now(){d_acceptingTasks = false;std::deque<Runnable> remaining;{std::lock_guard<std::mutex> lck(d_state->d_mutex);d_state->d_isShutdown = true;d_state->d_tasks.swap(remaining);}d_state->d_signalTaskAdded.notify_all();return remaining;}template <class Rep, class Period>
bool await_termination(const std::chrono::duration<Rep, Period>& timeout){std::unique_lock<std::mutex> lck(d_state->d_mutex);if (!d_state->d_handles.empty()){bool triggered = d_state->d_signalThreadDespawn.wait_for(lck, timeout, [this]() {return d_state->d_handles.empty();});return triggered;}return true;}void execute(const Runnable& task){if (!d_acceptingTasks){throw rejected_execution_error("Thread pool is no longer accepting tasks");}{std::unique_lock<std::mutex> lck(d_state->d_mutex);d_state->d_tasks.push_back(task);if (d_state->d_tasks.size() + d_state->d_activeThreads > d_state->d_handles.size() && d_state->d_handles.size() < d_state->d_maxThreads){add_thread();}}d_state->d_signalTaskAdded.notify_one();}template <class T>
std::future<T> submit(const Callable<T>& task){std::shared_ptr<std::promise<T>> prms = std::make_shared<std::promise<T>>();execute(bind_promise(task, prms));return prms->get_future();}private:void add_thread(){std::thread thr(&thread_pool::thread_loop, d_state);auto id = thr.get_id();d_state->d_handles[id] = std::move(thr);d_state->d_handles[id].detach();}template <class T>
Runnable bind_promise(const Callable<T>& task, const std::shared_ptr<std::promise<T>>& prms){return [prms, task]() {try{prms->set_value(task());}catch (const std::exception& ex){prms->set_exception(std::current_exception());}};}Runnable bind_promise(const Runnable& task, const std::shared_ptr<std::promise<void>>& prms){return [prms, task]() {try{task();prms->set_value();}catch (const std::exception& ex){prms->set_exception(std::current_exception());}};}static void thread_loop(std::shared_ptr<shared_state> state){std::unique_lock<std::mutex> lck(state->d_mutex);while (true){if (!state->d_tasks.empty()){auto job = state->d_tasks.front();state->d_tasks.pop_front();state->d_activeThreads++;lck.unlock();job();lck.lock();state->d_activeThreads--;}else if (!state->d_isShutdown){if (state->d_handles.size() > state->d_minThreads){bool triggered = state->d_signalTaskAdded.wait_for(lck, state->d_maxIdleTime, [&state]() {return !state->d_tasks.empty() || state->d_isShutdown;});if (!triggered && state->d_handles.size() > state->d_minThreads){break;}}else{state->d_signalTaskAdded.wait(lck, [&state]() {return !state->d_tasks.empty() || state->d_isShutdown;});}}else{break;}}state->d_handles.erase(std::this_thread::get_id());if (state->d_handles.empty()){state->d_signalThreadDespawn.notify_one();}}};} 
namespace stda {template <class Value, size_t SlotsPerBlock = 256>class pool_allocator{public:using value_type = Value;using size_type = size_t;using difference_type = ptrdiff_t;private:union pool_slot{value_type d_value;pool_slot* d_next_p;};struct pool_block{pool_block* d_next_p;uint8_t d_data_p[SlotsPerBlock * sizeof(pool_slot)];pool_block() : d_next_p(nullptr){for (size_t idx = 0; idx < SlotsPerBlock; idx++){size_t offset = idx * sizeof(pool_slot);pool_slot* slot = reinterpret_cast<pool_slot*>(d_data_p + offset);slot->d_next_p = idx < SlotsPerBlock - 1 ? slot + 1 : nullptr;}}};pool_block* d_blocks_p;pool_slot* d_head_p;std::allocator<value_type> d_multiAllocator;public:pool_allocator() : d_blocks_p(nullptr), d_head_p(nullptr){}~pool_allocator(){pool_block* curr_block = d_blocks_p;pool_block* next_block;while (curr_block != nullptr){next_block = curr_block->d_next_p;delete curr_block;curr_block = next_block;}}pool_allocator& operator=(pool_allocator other){std::swap(*this, other);return *this;}value_type* allocate(size_type n = 1){if (n == 1){if (d_head_p == nullptr){pool_block* new_block = new pool_block();new_block->d_next_p = d_blocks_p;d_blocks_p = new_block;d_head_p = reinterpret_cast<pool_slot*>(d_blocks_p->d_data_p);}value_type* value = &d_head_p->d_value;d_head_p = d_head_p->d_next_p;return value;}else{return d_multiAllocator.allocate(n);}}void deallocate(value_type* p, size_type n = 1){if (p == nullptr){return;}if (n == 1){pool_slot* slot = reinterpret_cast<pool_slot*>(p);slot->d_next_p = d_head_p;d_head_p = slot;}else{d_multiAllocator.deallocate(p, n);}}};} 
namespace stda {template <class T, class Compare = std::less<T>>class pairing_heap{public:using value_type = T;using value_compare = Compare;using size_type = size_t;private:struct pairing_node{pairing_node() : d_leftmostChild_p(nullptr), d_nextSibling_p(nullptr){}T d_value;pairing_node* d_leftmostChild_p;pairing_node* d_nextSibling_p;};using allocator = stda::pool_allocator<pairing_node>;size_type d_numElements;pairing_node* d_root_p;value_compare d_compare;allocator d_alloc;std::allocator_traits<allocator> d_allocTraits;public:pairing_heap() : pairing_heap(value_compare()) {}pairing_heap(const value_compare& compare) : d_numElements(0),d_root_p(nullptr),d_compare(compare){}pairing_heap(const pairing_heap& other) : d_numElements(other.d_numElements),d_root_p(nullptr),d_compare(other.d_compare){std::vector<std::pair<pairing_node*,std::reference_wrapper<pairing_node*>>>
frontier;frontier.push_back({other.d_root_p, d_root_p});while (!frontier.empty()){auto current = frontier.back();frontier.pop_back();auto original = current.first;if (original != nullptr){auto duplicate = d_allocTraits.allocate(d_alloc, 1);d_allocTraits.construct(d_alloc, duplicate);current.second.get() = duplicate;duplicate->d_value = original->d_value;frontier.push_back({original->d_leftmostChild_p,duplicate->d_leftmostChild_p});frontier.push_back({original->d_nextSibling_p,duplicate->d_nextSibling_p});}}}~pairing_heap(){std::vector<pairing_node*> frontier;frontier.push_back(d_root_p);while (!frontier.empty()){auto current = frontier.back();frontier.pop_back();if (current != nullptr){frontier.push_back(current->d_leftmostChild_p);frontier.push_back(current->d_nextSibling_p);d_allocTraits.destroy(d_alloc, current);d_allocTraits.deallocate(d_alloc, current, 1);}}}pairing_heap& operator=(pairing_heap other){std::swap(*this, other);return *this;}const T& top() const{return d_root_p->d_value;}void push(const value_type& value){auto node = d_allocTraits.allocate(d_alloc, 1);d_allocTraits.construct(d_alloc, node);node->d_value = value;d_root_p = merge_pointers(d_root_p, node);d_numElements++;}void pop(){if (d_numElements == 0){return;}pairing_node* current = d_root_p->d_leftmostChild_p;d_allocTraits.destroy(d_alloc, d_root_p);d_allocTraits.deallocate(d_alloc, d_root_p, 1);d_root_p = nullptr;d_numElements--;pairing_node* previous = nullptr;while (current != nullptr){pairing_node* nxt = current->d_nextSibling_p;pairing_node* nxt2 = nullptr;if (nxt != nullptr){nxt2 = nxt->d_nextSibling_p;current->d_nextSibling_p = nullptr;nxt->d_nextSibling_p = nullptr;current = merge_pointers(current, nxt);}current->d_nextSibling_p = previous;previous = current;current = nxt2;}while (previous != nullptr){pairing_node* nxt = previous->d_nextSibling_p;previous->d_nextSibling_p = nullptr;d_root_p = merge_pointers(d_root_p, previous);previous = nxt;}}void merge(pairing_heap& other){d_root_p = merge_pointers(d_root_p, other.d_root_p);d_numElements += other.d_numElements;other.d_root_p = nullptr;other.d_numElements = 0;}bool empty() const{return d_numElements == 0;}size_type size() const{return d_numElements;}friend std::ostream& operator<<(std::ostream& stream, const pairing_heap& heap){return heap.print_recursive(stream, heap.m_root, 0) << std::endl;}private:pairing_node* merge_pointers(pairing_node* heap1, pairing_node* heap2) const{if (heap1 == nullptr){return heap2;}if (heap2 == nullptr){return heap1;}if (!d_compare(heap1->d_value, heap2->d_value)){std::swap(heap1, heap2);}pairing_node* left_subheap = heap1->d_leftmostChild_p;heap1->d_leftmostChild_p = heap2;heap2->d_nextSibling_p = left_subheap;return heap1;}std::ostream& print_recursive(std::ostream& stream, const pairing_node* const node, int level) const{if (node == nullptr){return stream;}stream << node->d_value << " | ";if (node->d_leftmostChild_p != nullptr){stream << std::endl;for (int i = 0; i < level + 1; i++)stream << " ";print_recursive(stream, node->d_leftmostChild_p, level + 1);if (node->d_nextSibling_p != nullptr){stream << std::endl;for (int i = 0; i < level; i++)stream << " ";}}print_recursive(stream, node->d_nextSibling_p, level);return stream;}};} 
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__)) || defined(_M_X64) || defined(__ia64) || defined(_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
#define NUM_HASHTABLE_PRIMES 62
#else
#define NUM_HASHTABLE_PRIMES 30
#endif
namespace stda {const size_t HASHTABLE_PRIMES[62] = {5ul,11ul,23ul,47ul,97ul,199ul,409ul,823ul,1741ul,3469ul,6949ul,14033ul,28411ul,57557ul,116731ul,236897ul,480881ul,976369ul,1982627ul,4026031ul,8175383ul,16601593ul,33712729ul,68460391ul,139022417ul,282312799ul,573292817ul,1164186217ul,2364114217ul,4294967291ul,static_cast<size_t>(8589934583ull),static_cast<size_t>(17179869143ull),static_cast<size_t>(34359738337ull),static_cast<size_t>(68719476731ull),static_cast<size_t>(137438953447ull),static_cast<size_t>(274877906899ull),static_cast<size_t>(549755813881ull),static_cast<size_t>(1099511627689ull),static_cast<size_t>(2199023255531ull),static_cast<size_t>(4398046511093ull),static_cast<size_t>(8796093022151ull),static_cast<size_t>(17592186044399ull),static_cast<size_t>(35184372088777ull),static_cast<size_t>(70368744177643ull),static_cast<size_t>(140737488355213ull),static_cast<size_t>(281474976710597ull),static_cast<size_t>(562949953421231ull),static_cast<size_t>(1125899906842597ull),static_cast<size_t>(2251799813685119ull),static_cast<size_t>(4503599627370449ull),static_cast<size_t>(9007199254740881ull),static_cast<size_t>(18014398509481951ull),static_cast<size_t>(36028797018963913ull),static_cast<size_t>(72057594037927931ull),static_cast<size_t>(144115188075855859ull),static_cast<size_t>(288230376151711717ull),static_cast<size_t>(576460752303423433ull),static_cast<size_t>(1152921504606846883ull),static_cast<size_t>(2305843009213693951ull),static_cast<size_t>(4611686018427387847ull),static_cast<size_t>(9223372036854775783ull),static_cast<size_t>(18446744073709551557ull),};inline size_t mod_using_prime_index(size_t hsh, size_t prime_index, size_t fallback_modulus){switch (prime_index){case 0:return hsh % 5ul;case 1:return hsh % 11ul;case 2:return hsh % 23ul;case 3:return hsh % 47ul;case 4:return hsh % 97ul;case 5:return hsh % 199ul;case 6:return hsh % 409ul;case 7:return hsh % 823ul;case 8:return hsh % 1741ul;case 9:return hsh % 3469ul;case 10:return hsh % 6949ul;case 11:return hsh % 14033ul;case 12:return hsh % 28411ul;case 13:return hsh % 57557ul;case 14:return hsh % 116731ul;case 15:return hsh % 236897ul;case 16:return hsh % 480881ul;case 17:return hsh % 976369ul;case 18:return hsh % 1982627ul;case 19:return hsh % 4026031ul;case 20:return hsh % 8175383ul;case 21:return hsh % 16601593ul;case 22:return hsh % 33712729ul;case 23:return hsh % 68460391ul;case 24:return hsh % 139022417ul;case 25:return hsh % 282312799ul;case 26:return hsh % 573292817ul;case 27:return hsh % 1164186217ul;case 28:return hsh % 2364114217ul;case 29:return hsh % 4294967291ul;case 30:return hsh % 8589934583ull;case 31:return hsh % 17179869143ull;case 32:return hsh % 34359738337ull;case 33:return hsh % 68719476731ull;case 34:return hsh % 137438953447ull;case 35:return hsh % 274877906899ull;case 36:return hsh % 549755813881ull;case 37:return hsh % 1099511627689ull;case 38:return hsh % 2199023255531ull;case 39:return hsh % 4398046511093ull;case 40:return hsh % 8796093022151ull;case 41:return hsh % 17592186044399ull;case 42:return hsh % 35184372088777ull;case 43:return hsh % 70368744177643ull;case 44:return hsh % 140737488355213ull;case 45:return hsh % 281474976710597ull;case 46:return hsh % 562949953421231ull;case 47:return hsh % 1125899906842597ull;case 48:return hsh % 2251799813685119ull;case 49:return hsh % 4503599627370449ull;case 50:return hsh % 9007199254740881ull;case 51:return hsh % 18014398509481951ull;case 52:return hsh % 36028797018963913ull;case 53:return hsh % 72057594037927931ull;case 54:return hsh % 144115188075855859ull;case 55:return hsh % 288230376151711717ull;case 56:return hsh % 576460752303423433ull;case 57:return hsh % 1152921504606846883ull;case 58:return hsh % 2305843009213693951ull;case 59:return hsh % 4611686018427387847ull;case 60:return hsh % 9223372036854775783ull;case 61:return hsh % 18446744073709551557ull;default:return hsh % fallback_modulus; }}inline size_t find_next_prime_index(size_t num){size_t left = 0;size_t right = NUM_HASHTABLE_PRIMES - 1;if (num < HASHTABLE_PRIMES[left]){return left;}if (num > HASHTABLE_PRIMES[right]){return NUM_HASHTABLE_PRIMES;}size_t median;size_t prime;while (left <= right){median = (left + right) / 2;prime = HASHTABLE_PRIMES[median];if (num == prime){return median;}else if (num < prime){right = median - 1;}else{left = median + 1;}}return num > HASHTABLE_PRIMES[right] ? right + 1 : right;}} 
namespace stda {template <class Key, class Mapped>class node_robin_map{private:static const size_t DEFAULT_BUCKET_COUNT = 97;static constexpr float DEFAULT_LOAD_FACTOR = 0.8F;static constexpr float SPARSE_LOAD_FACTOR = 0.1F;public:using key_type = Key;using mapped_type = Mapped;using value_type = std::pair<Key, Mapped>;using size_type = size_t;using hasher = std::hash<Key>;using key_equal = std::equal_to<Key>;template <bool IsConst>class robin_iterator : public std::iterator<std::forward_iterator_tag, value_type>{private:node_robin_map& d_parent;size_type d_idx;public:using reference = typename std::conditional<IsConst, value_type const&, value_type&>::type;using pointer = typename std::conditional<IsConst, value_type const*, value_type*>::type;robin_iterator(node_robin_map& parent, size_type idx) : d_parent(parent), d_idx(idx) {}robin_iterator& operator++(){d_idx++;return *this;}robin_iterator operator++(int){auto retval = *this;++(*this);return retval;}bool operator==(robin_iterator other) const{return &d_parent == &other.d_parent && d_idx == other.d_idx;}bool operator!=(robin_iterator other) const{return !(*this == other);}reference operator*(){return d_parent.d_values_p[d_idx];}pointer operator->(){return d_parent.d_values_p + d_idx;}};using iterator = robin_iterator<false>;using const_iterator = robin_iterator<true>;private:struct robin_bucket{size_type d_valIdx;size_type d_probeDist;bool d_full;};size_type d_primeIdx;size_type d_numBuckets;size_type d_numElements;float d_maxLdFactor;size_type d_maxProbeDist;robin_bucket* d_buckets_p;value_type* d_values_p;size_type* d_valsToBuckets_p;public:node_robin_map() : node_robin_map(DEFAULT_BUCKET_COUNT) {}node_robin_map(size_type proposed_buckets) : d_primeIdx(NUM_HASHTABLE_PRIMES),d_numBuckets(0),d_numElements(0),d_maxLdFactor(DEFAULT_LOAD_FACTOR),d_maxProbeDist(0),d_buckets_p(nullptr),d_values_p(nullptr),d_valsToBuckets_p(nullptr){d_primeIdx = find_next_prime_index(proposed_buckets);if (d_primeIdx == NUM_HASHTABLE_PRIMES){throw new std::bad_alloc();}d_numBuckets = HASHTABLE_PRIMES[d_primeIdx];d_buckets_p = new robin_bucket[d_numBuckets]();d_values_p = new value_type[d_numBuckets]();d_valsToBuckets_p = new size_type[d_numBuckets];}node_robin_map(const node_robin_map& other) : d_primeIdx(other.d_primeIdx),d_numBuckets(other.d_numBuckets),d_numElements(other.d_numElements),d_maxLdFactor(other.d_maxLdFactor),d_maxProbeDist(other.d_maxProbeDist),d_buckets_p(new robin_bucket[other.d_numBuckets]()),d_values_p(new value_type[other.d_numBuckets]()),d_valsToBuckets_p(new size_type[other.d_numBuckets]){std::copy(other.d_buckets_p, other.d_buckets_p + d_numBuckets, d_buckets_p);std::copy(other.d_values_p, other.d_values_p + d_numElements, d_values_p);std::copy(other.d_valsToBuckets_p, other.d_valsToBuckets_p + d_numElements, d_valsToBuckets_p);}~node_robin_map(){delete[] d_buckets_p;delete[] d_values_p;delete[] d_valsToBuckets_p;}node_robin_map& operator=(node_robin_map other){std::swap(*this, other);return *this;}iterator find(const key_type& key){return iterator(*this, robin_find(key));}const_iterator find(const key_type& key) const{return const_iterator(*this, robin_find(key));}mapped_type& at(const key_type& key){auto result = robin_find(key);if (result == d_numElements){throw std::out_of_range("Key not in map.");}return d_values_p[result].second;}const mapped_type& at(const key_type& key) const{return at(key);}bool contains(const key_type& key) const{return find(key) != end();}std::pair<iterator, bool> insert(const value_type& value){size_type num_curr_elements = d_numElements;auto result = robin_insert(value.first, value.second);return std::make_pair(iterator(*this, result), d_numElements > num_curr_elements);}mapped_type& operator[](const key_type& key){auto result = robin_insert(key, mapped_type());return d_values_p[result].second;}void clear() noexcept{if (load_factor() < SPARSE_LOAD_FACTOR * static_cast<float>(d_numElements)){for (size_type i = 0; i < d_numElements; i++){d_buckets_p[d_valsToBuckets_p[i]].d_full = false;}}else{for (size_type i = 0; i < d_numBuckets; i++){d_buckets_p[i].d_full = false;}}d_numElements = 0;d_maxProbeDist = 0;}size_type erase(const key_type& key){return robin_delete(key) ? 1 : 0;}iterator begin(){return iterator(*this, 0);}const_iterator begin() const{return const_iterator(*this, 0);}const_iterator cbegin() const{return const_iterator(*this, 0);}iterator end(){return iterator(*this, d_numElements);}const_iterator end() const{return const_iterator(*this, d_numElements);}const_iterator cend() const{return const_iterator(*this, d_numElements);}bool empty() const{return d_numElements == 0;}size_type size() const{return d_numElements;}float load_factor() const{return static_cast<float>(d_numElements) / static_cast<float>(d_numBuckets);}float max_load_factor() const{return d_maxLdFactor;}void max_load_factor(float new_ld_factor){if (new_ld_factor < 0.0F || new_ld_factor > 1.0F){throw std::out_of_range("Maximum load factors must be in the range [0, 1].");}d_maxLdFactor = new_ld_factor;}size_type bucket_count() const{return d_numBuckets;}float average_probe_distance() const{size_type sum = 0;for (size_type i = 0; i < d_numBuckets; i++){if (d_buckets_p[i].full){sum += d_buckets_p[i].d_probeDist;}}return static_cast<float>(sum) / d_numElements;}size_type max_probe_distance() const{return d_maxProbeDist;}void reserve(size_type proposed_elements){rehash(static_cast<size_type>(proposed_elements / d_maxLdFactor));}void rehash(size_type proposed_buckets){if (proposed_buckets <= d_numBuckets){return;}size_type proposed_prime_index = find_next_prime_index(proposed_buckets);if (proposed_prime_index >= NUM_HASHTABLE_PRIMES){throw std::bad_alloc();}robin_resize(proposed_prime_index);}private:void robin_resize(size_type valid_greater_prime_index){d_primeIdx = valid_greater_prime_index;size_type num_new_buckets = HASHTABLE_PRIMES[d_primeIdx];auto old_values = d_values_p;d_values_p = new value_type[num_new_buckets]();std::copy(old_values, old_values + d_numBuckets, d_values_p);delete[] old_values;delete[] d_buckets_p;d_buckets_p = new robin_bucket[num_new_buckets]();d_numBuckets = num_new_buckets;delete[] d_valsToBuckets_p;d_valsToBuckets_p = new size_type[num_new_buckets];d_maxProbeDist = 0;for (size_type idx = 0; idx < d_numElements; idx++){robin_raw_insert(idx);}}size_type robin_raw_insert(size_type val_idx){const key_type& key = d_values_p[val_idx].first;const size_type initial_bckt_idx = mod_using_prime_index(hasher{}(key), d_primeIdx, d_numBuckets);size_type ret_idx = val_idx;bool no_swap = true;bool resize_necessary = load_factor() >= d_maxLdFactor;size_type bckt_idx = initial_bckt_idx;for (size_type dist = 0; dist < d_numBuckets; dist++){robin_bucket* bckt = d_buckets_p + bckt_idx;if (!bckt->d_full){bckt->d_valIdx = val_idx;bckt->d_probeDist = dist;bckt->d_full = true;d_valsToBuckets_p[val_idx] = bckt_idx;if (dist > d_maxProbeDist){d_maxProbeDist = dist;}break;}if (no_swap && dist < d_maxProbeDist + 1){size_type target_bckt_idx = initial_bckt_idx + bckt->d_probeDist;if (target_bckt_idx >= d_numBuckets)target_bckt_idx -= d_numBuckets;if (target_bckt_idx == bckt_idx && key_equal{}(key, d_values_p[bckt->d_valIdx].first)){ret_idx = bckt->d_valIdx;d_numElements--;break;}}if (dist > bckt->d_probeDist){if (no_swap && resize_necessary && d_primeIdx >= NUM_HASHTABLE_PRIMES - 1){throw std::bad_alloc();}no_swap = false;if (dist > d_maxProbeDist){d_maxProbeDist = dist;}d_valsToBuckets_p[val_idx] = bckt_idx;std::swap(bckt->d_valIdx, val_idx);std::swap(bckt->d_probeDist, dist);}bckt_idx++;if (bckt_idx == d_numBuckets){bckt_idx = 0;}}if (resize_necessary){robin_resize(d_primeIdx + 1);}return ret_idx;}size_type robin_insert(const key_type& key, const mapped_type& data){d_values_p[d_numElements] = {key, data};return robin_raw_insert(d_numElements++);}size_type robin_find(const key_type& key) const{const size_type initial_bckt_idx = mod_using_prime_index(hasher{}(key), d_primeIdx, d_numBuckets);size_type bckt_idx = initial_bckt_idx;for (size_type dist = 0; dist <= d_maxProbeDist; dist++){robin_bucket* bckt = d_buckets_p + bckt_idx;size_type val_idx = bckt->d_valIdx;if (!bckt->d_full){break;}size_type target_bckt_idx = initial_bckt_idx + bckt->d_probeDist;if (target_bckt_idx >= d_numBuckets){target_bckt_idx -= d_numBuckets;}if (target_bckt_idx == bckt_idx && key_equal{}(key, d_values_p[val_idx].first)){return val_idx;}if (dist > bckt->d_probeDist){break;}bckt_idx++;if (bckt_idx == d_numBuckets){bckt_idx = 0;}}return d_numElements;}bool robin_delete(const key_type& key){size_type val_idx = robin_find(key);if (val_idx == d_numElements){return false;}const size_type remove_val_idx = val_idx;const size_type remove_bckt_idx = static_cast<size_type>(d_valsToBuckets_p[val_idx]);size_type prev_bckt_idx = remove_bckt_idx;robin_bucket* prev_bckt = d_buckets_p + prev_bckt_idx;for (size_type dist = 0; dist < d_numBuckets - 1; dist++){size_type bckt_idx = prev_bckt_idx + 1;if (bckt_idx == d_numBuckets){bckt_idx = 0;}robin_bucket* bckt = d_buckets_p + bckt_idx;if (!bckt->d_full || bckt->d_probeDist == 0){break;}prev_bckt->d_valIdx = bckt->d_valIdx;prev_bckt->d_probeDist = bckt->d_probeDist - 1;d_valsToBuckets_p[bckt->d_valIdx] = prev_bckt_idx;prev_bckt_idx = bckt_idx;prev_bckt = bckt;}prev_bckt->d_full = false;if (remove_val_idx < d_numElements - 1){size_type last_val_idx = d_numElements - 1;d_values_p[remove_val_idx] = std::move(d_values_p[last_val_idx]);size_type last_bckt_idx = d_valsToBuckets_p[last_val_idx];robin_bucket* last_bckt = d_buckets_p + last_bckt_idx;last_bckt->d_valIdx = remove_val_idx;d_valsToBuckets_p[remove_val_idx] = last_bckt_idx;}d_numElements--;return true;}};} 
namespace stda {template <class Key, class Mapped>class flat_robin_map{private:static const size_t DEFAULT_BUCKET_COUNT = 97;static constexpr float DEFAULT_LOAD_FACTOR = 0.8F;static constexpr float SPARSE_LOAD_FACTOR = 0.1F;public:using key_type = Key;using mapped_type = Mapped;using value_type = std::pair<Key, Mapped>;using size_type = size_t;using hasher = std::hash<Key>;using key_equal = std::equal_to<Key>;template <bool IsConst>class robin_iterator : public std::iterator<std::forward_iterator_tag, value_type>{private:flat_robin_map& d_parent;size_type d_idx;public:using reference = typename std::conditional<IsConst, value_type const&, value_type&>::type;using pointer = typename std::conditional<IsConst, value_type const*, value_type*>::type;robin_iterator(flat_robin_map& parent, size_type idx) : d_parent(parent), d_idx(idx) {}robin_iterator& operator++(){d_idx++;return *this;}robin_iterator operator++(int){auto retval = *this;++(*this);return retval;}bool operator==(robin_iterator other) const{return &d_parent == &other.d_parent && d_idx == other.d_idx;}bool operator!=(robin_iterator other) const{return !(*this == other);}reference operator*(){return d_parent.d_buckets_p[d_parent.d_positions_p[d_idx]].d_value;}pointer operator->(){return &d_parent.d_buckets_p[d_parent.d_positions_p[d_idx]].d_value;}};using iterator = robin_iterator<false>;using const_iterator = robin_iterator<true>;private:struct robin_bucket{value_type d_value;size_type d_posIdx;size_type d_probeDist;bool d_full;};size_type d_primeIdx;size_type d_numBuckets;size_type d_numElements;float d_maxLdFactor;size_type d_maxProbeDist;robin_bucket* d_buckets_p;size_type* d_positions_p; public:flat_robin_map() : flat_robin_map(DEFAULT_BUCKET_COUNT) {}flat_robin_map(size_type proposed_buckets) : d_primeIdx(NUM_HASHTABLE_PRIMES),d_numBuckets(0),d_numElements(0),d_maxLdFactor(DEFAULT_LOAD_FACTOR),d_maxProbeDist(0),d_buckets_p(nullptr),d_positions_p(nullptr){d_primeIdx = find_next_prime_index(proposed_buckets);if (d_primeIdx == NUM_HASHTABLE_PRIMES){throw new std::bad_alloc();}d_numBuckets = HASHTABLE_PRIMES[d_primeIdx];d_buckets_p = new robin_bucket[d_numBuckets]();d_positions_p = new size_type[d_numBuckets];}flat_robin_map(const flat_robin_map& other) : d_primeIdx(other.d_primeIdx),d_numBuckets(other.d_numBuckets),d_numElements(other.d_numElements),d_maxLdFactor(other.d_maxLdFactor),d_maxProbeDist(other.d_maxProbeDist),d_buckets_p(new robin_bucket[other.d_numBuckets]()),d_positions_p(new size_type[other.d_numBuckets]){std::copy(other.d_buckets_p, other.d_buckets_p + d_numBuckets, d_buckets_p);std::copy(other.d_positions_p, other.d_positions_p + d_numElements, d_positions_p);}~flat_robin_map(){delete[] d_buckets_p;delete[] d_positions_p;}flat_robin_map& operator=(flat_robin_map other){std::swap(*this, other);return *this;}iterator find(const key_type& key){return iterator(*this, robin_find(key));}const_iterator find(const key_type& key) const{return const_iterator(*this, robin_find(key));}mapped_type& at(const key_type& key){auto result = robin_find(key);if (result == d_numElements){throw std::out_of_range("Key not in map.");}return d_buckets_p[d_positions_p[result]].d_value.second;}const mapped_type& at(const key_type& key) const{return at(key);}bool contains(const key_type& key) const{return find(key) != end();}std::pair<iterator, bool> insert(const value_type& value){size_type num_curr_elements = d_numElements;auto result = robin_insert(value);return std::make_pair(iterator(*this, result), d_numElements > num_curr_elements);}mapped_type& operator[](const key_type& key){auto result = robin_insert({key, Mapped()});return d_buckets_p[d_positions_p[result]].d_value.second;}void clear() noexcept{if (load_factor() < SPARSE_LOAD_FACTOR * static_cast<float>(d_numElements)){for (size_type i = 0; i < d_numElements; i++){d_buckets_p[d_positions_p[i]].d_full = false;}}else{for (size_type i = 0; i < d_numBuckets; i++){d_buckets_p[i].d_full = false;}}d_numElements = 0;d_maxProbeDist = 0;}size_type erase(const key_type& key){return robin_delete(key) ? 1 : 0;}iterator begin(){return iterator(*this, 0);}const_iterator begin() const{return const_iterator(*this, 0);}const_iterator cbegin() const{return const_iterator(*this, 0);}iterator end(){return iterator(*this, d_numElements);}const_iterator end() const{return const_iterator(*this, d_numElements);}const_iterator cend() const{return const_iterator(*this, d_numElements);}bool empty() const{return d_numElements == 0;}size_type size() const{return d_numElements;}float load_factor() const{return static_cast<float>(d_numElements) / static_cast<float>(d_numBuckets);}float max_load_factor() const{return d_maxLdFactor;}void max_load_factor(float new_ld_factor){if (new_ld_factor < 0.0F || new_ld_factor > 1.0F){throw std::out_of_range("Maximum load factors must be in the range [0, 1].");}d_maxLdFactor = new_ld_factor;}size_type bucket_count() const{return d_numBuckets;}float average_probe_distance() const{size_type sum = 0;for (size_type i = 0; i < d_numBuckets; i++){if (d_buckets_p[i].d_full){sum += d_buckets_p[i].d_probeDist;}}return static_cast<float>(sum) / d_numElements;}size_type max_probe_distance() const{return d_maxProbeDist;}void reserve(size_type proposed_elements){rehash(static_cast<size_type>(proposed_elements / d_maxLdFactor));}void rehash(size_type proposed_buckets){if (proposed_buckets <= d_numBuckets){return;}size_type proposed_prime_index = find_next_prime_index(proposed_buckets);if (proposed_prime_index >= NUM_HASHTABLE_PRIMES){throw std::bad_alloc();}robin_resize(proposed_prime_index);}private:void robin_resize(size_type valid_greater_prime_index){d_primeIdx = valid_greater_prime_index;size_type num_new_buckets = HASHTABLE_PRIMES[valid_greater_prime_index];auto old_buckets = d_buckets_p;auto old_num_buckets = d_numBuckets;delete[] d_positions_p;d_buckets_p = new robin_bucket[num_new_buckets]();d_positions_p = new size_type[num_new_buckets];d_numBuckets = num_new_buckets;d_numElements = 0;d_maxProbeDist = 0;for (size_type bidx = 0; bidx < old_num_buckets; bidx++){if (old_buckets[bidx].d_full){robin_insert(old_buckets[bidx].d_value);}}delete[] old_buckets;}size_type robin_insert(const value_type& insertion){value_type val = insertion;const key_type& key = insertion.first;const size_type initial_bckt_idx = mod_using_prime_index(hasher{}(key), d_primeIdx, d_numBuckets);bool no_swap = true;size_type bckt_idx = initial_bckt_idx;size_type ret_iter_idx = d_numElements;d_numElements++;bool resize_necessary = load_factor() >= d_maxLdFactor;d_numElements--;for (size_type dist = 0; dist < d_numBuckets; dist++){robin_bucket* bckt = d_buckets_p + bckt_idx;if (!bckt->d_full){bckt->d_value = val;bckt->d_posIdx = d_numElements;bckt->d_probeDist = dist;bckt->d_full = true;d_positions_p[d_numElements] = bckt_idx;d_numElements++;if (dist > d_maxProbeDist){d_maxProbeDist = dist;}break;}if (no_swap && dist <= d_maxProbeDist){size_type target_bckt_idx = initial_bckt_idx + bckt->d_probeDist;if (target_bckt_idx >= d_numBuckets){target_bckt_idx -= d_numBuckets;}if (target_bckt_idx == bckt_idx && key_equal{}(key, bckt->d_value.first)){return bckt->d_posIdx;}}if (dist > bckt->d_probeDist){if (no_swap && resize_necessary && d_primeIdx >= NUM_HASHTABLE_PRIMES - 1){throw std::bad_alloc();}if (no_swap){ret_iter_idx = bckt->d_posIdx;}no_swap = false;if (dist > d_maxProbeDist){d_maxProbeDist = dist;}std::swap(bckt->d_value, val);std::swap(bckt->d_probeDist, dist);}bckt_idx++;if (bckt_idx == d_numBuckets){bckt_idx = 0;}}if (resize_necessary){robin_resize(d_primeIdx + 1);return robin_find(key);}return ret_iter_idx;}size_type robin_find(const key_type& key) const{const size_type initial_bckt_idx = mod_using_prime_index(hasher{}(key), d_primeIdx, d_numBuckets);size_type bckt_idx = initial_bckt_idx;for (size_type dist = 0; dist <= d_maxProbeDist; dist++){robin_bucket* bckt = d_buckets_p + bckt_idx;if (!bckt->d_full){break;}size_type target_bckt_idx = initial_bckt_idx + bckt->d_probeDist;if (target_bckt_idx >= d_numBuckets){target_bckt_idx -= d_numBuckets;}if (target_bckt_idx == bckt_idx && key_equal{}(key, bckt->d_value.first)){return bckt->d_posIdx;}if (dist > bckt->d_probeDist){break;}bckt_idx++;if (bckt_idx == d_numBuckets){bckt_idx = 0;}}return d_numElements;}bool robin_delete(const key_type& key){size_type iter_idx = robin_find(key);if (iter_idx == d_numElements){return false;}size_type prev_bckt_idx = d_positions_p[iter_idx];robin_bucket* prev_bckt = d_buckets_p + prev_bckt_idx;for (size_type dist = 0; dist < d_numBuckets - 1; dist++){size_type bckt_idx = prev_bckt_idx + 1;if (bckt_idx == d_numBuckets){bckt_idx = 0;}robin_bucket* bckt = d_buckets_p + bckt_idx;if (!bckt->d_full || bckt->d_probeDist == 0){break;}prev_bckt->d_value = bckt->d_value;prev_bckt->d_probeDist = bckt->d_probeDist - 1;prev_bckt_idx = bckt_idx;prev_bckt = bckt;}prev_bckt->d_full = false;const size_type remove_iter_idx = prev_bckt->d_posIdx;if (remove_iter_idx < d_numElements - 1){size_type last_iter_idx = d_numElements - 1;robin_bucket* last_bckt = d_buckets_p + d_positions_p[last_iter_idx];d_positions_p[remove_iter_idx] = d_positions_p[last_iter_idx];last_bckt->d_posIdx = remove_iter_idx;}d_numElements--;return true;}};} 
#endif